<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Slideshow v2.2 (Flat Log)</title>
    <style>
        :root {
            --saturation: 110%;          
            --brightness: 90%;          
            --animation-speed: 60s;        
            --transition-speed: 3s; 
        }

        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background-color: #000; overflow: hidden; }
        #bg-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
        
        #fade-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: #000; opacity: 0; z-index: 100; pointer-events: none; 
            transition: opacity 2s ease-in-out; 
        }
        #fade-overlay.black { opacity: 1; }

        .bg-layer {
            position: absolute; top: 0; left: 0; 
            width: 100vw; height: 100vh; 
            object-fit: cover; object-position: center center;
            opacity: 0; z-index: 1;
            transform: scale(1.0); 
            will-change: transform, opacity;
            transition: opacity var(--transition-speed) ease-in-out, filter 2s ease-in-out;
        }

        .bg-layer.fx-normal { filter: saturate(var(--saturation)) brightness(var(--brightness)); }
        
        .bg-layer.fx-blur {
            filter: blur(5px) saturate(105%) brightness(60%);
            transform: scale(1.1); 
        }

        .bg-layer.active { 
            opacity: 1; z-index: 10; 
            animation: drift var(--animation-speed) infinite alternate ease-in-out; 
        }

        .bg-layer.next { 
            opacity: 1; z-index: 11; 
            animation: drift var(--animation-speed) infinite alternate ease-in-out; 
        }

        .bg-layer.idle { opacity: 0; z-index: 1; animation: none; }

        @keyframes drift {
            0% { transform: scale(1.0) translate(0, 0); }
            100% { transform: scale(1.15) translate(2%, 1%); }
        }
        
        .bg-layer.fx-blur.active, .bg-layer.fx-blur.next {
            animation: drift-blur var(--animation-speed) infinite alternate ease-in-out;
        }
        @keyframes drift-blur {
            0% { transform: scale(1.1) translate(0, 0); }
            100% { transform: scale(1.25) translate(2%, 1%); }
        }

        #debug-status { 
            position: fixed; bottom: 20px; left: 20px; 
            color: rgba(255,255,255,0.6); font-family: 'Courier New', monospace; 
            font-size: 14px; text-shadow: 0px 2px 4px rgba(0,0,0,0.8);
            z-index: 200; pointer-events: none; opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
        }
        #debug-status.visible { opacity: 1; }
    </style>
</head>
<body>

    <div id="debug-status">Initializing System...</div>

    <div id="bg-container">
        <div id="fade-overlay"></div>
        <img id="layer-a" class="bg-layer idle" src="" alt="">
        <img id="layer-b" class="bg-layer idle" src="" alt="">
    </div>

    <script src="themes.js"></script>

    <script>
        // --- CONFIG ---
        const LASTFM_API_KEY = "6c9c00e45e415acfc71a217c7ba023c8";
        const LASTFM_USER = "Hollander33";
        const BASE_IMG_PATH = "./assets/"; 
        const SLIDE_DURATION_MS = 12000; 

        // --- STATE & SECURITY ---
        let currentTrackId = "";
        let activeLayerId = 'layer-a'; 
        
        // Timers
        let slideTimeout = null;
        let transitionTimeout = null; 
        let idleTimer = null;
        let statusTextTimer = null;

        // Flags
        let isIdle = false;
        let isSlideshowRunning = false;
        
        // Data
        let imageDeck = []; 
        let currentTheme = null;

        // SECURITY: Execution ID
        let currentExecutionID = 0; 

        const debugText = document.getElementById("debug-status");
        const fadeOverlay = document.getElementById("fade-overlay");

        function setStatus(msg) { 
            debugText.innerText = "> " + msg; 
            debugText.classList.add('visible');
            if (statusTextTimer) clearTimeout(statusTextTimer);
            statusTextTimer = setTimeout(() => debugText.classList.remove('visible'), 5000);
        }

        function shuffleDeck(count) {
            let deck = Array.from({length: count}, (_, i) => i + 1);
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // --- ENGINE CORE ---

        async function runSlideshowLoop(myExecutionID) {
            if (!isSlideshowRunning || myExecutionID !== currentExecutionID) return;

            let nextUrl = "";
            let logMsg = "";

            if (currentTheme) {
                if (imageDeck.length === 0) {
                    imageDeck = shuffleDeck(currentTheme.count);
                    console.log("%c üîÄ Deck Reshuffled", "color: #555; font-style: italic;");
                }
                const index = imageDeck.pop();
                nextUrl = `${BASE_IMG_PATH}${currentTheme.folder}/${index}.jpg`;
                logMsg = `%c üì∏ SLIDE: #${index} (${currentTheme.folder})`;
            } else {
                return;
            }

            try {
                await preloadAndDecode(nextUrl);
                
                if (!isSlideshowRunning || myExecutionID !== currentExecutionID) return;

                performTransition(nextUrl, false); 
                console.log(logMsg, "color: #b35900; font-weight: bold;");

                slideTimeout = setTimeout(() => runSlideshowLoop(myExecutionID), SLIDE_DURATION_MS);

            } catch (err) {
                console.error("‚ùå Image Load Error:", err);
                if (isSlideshowRunning && myExecutionID === currentExecutionID) {
                    slideTimeout = setTimeout(() => runSlideshowLoop(myExecutionID), 2000); 
                }
            }
        }

        function preloadAndDecode(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = url;
                if (img.decode) {
                    img.decode().then(() => resolve(url)).catch(reject);
                } else {
                    img.onload = () => resolve(url);
                    img.onerror = reject;
                }
            });
        }

        function performTransition(url, isBlur) {
            if (transitionTimeout) {
                clearTimeout(transitionTimeout);
                transitionTimeout = null;
            }

            const activeEl = document.getElementById(activeLayerId);
            const nextLayerId = activeLayerId === 'layer-a' ? 'layer-b' : 'layer-a';
            const nextEl = document.getElementById(nextLayerId);

            nextEl.src = url;
            nextEl.className = 'bg-layer idle';
            if (isBlur) nextEl.classList.add('fx-blur');
            else nextEl.classList.add('fx-normal');

            void nextEl.offsetWidth; 

            nextEl.classList.remove('idle');
            nextEl.classList.add('next'); 

            transitionTimeout = setTimeout(() => {
                activeEl.className = 'bg-layer idle'; 
                nextEl.classList.remove('next');
                nextEl.classList.add('active'); 
                transitionTimeout = null;
            }, 3000); 

            activeLayerId = nextLayerId;
        }

        function startSlideshow(theme) {
            if (currentTheme !== theme) {
                imageDeck = []; 
            }
            currentTheme = theme;
            isSlideshowRunning = true;
            if (slideTimeout) clearTimeout(slideTimeout);
            runSlideshowLoop(currentExecutionID);
        }

        function stopSlideshow() {
            isSlideshowRunning = false;
            currentTheme = null;
            if (slideTimeout) clearTimeout(slideTimeout);
        }

        // --- API & LOGIC ---
        async function fetchLastFm() {
            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${LASTFM_USER}&api_key=${LASTFM_API_KEY}&format=json&limit=1`;
            try {
                const r = await fetch(url);
                const d = await r.json();
                const track = d.recenttracks?.track?.[0];
                
                if (!track) return;

                const isNowPlaying = track['@attr'] && track['@attr'].nowplaying === 'true';

                if (isNowPlaying) {
                    if (isIdle) {
                        isIdle = false;
                        fadeOverlay.classList.remove('black');
                        setStatus("Engine Online");
                    }
                    if (idleTimer) { clearTimeout(idleTimer); idleTimer = null; }

                    const uniqueId = track.name + track.artist['#text'];
                    if (uniqueId !== currentTrackId) {
                        
                        currentExecutionID++; 
                        currentTrackId = uniqueId;

                        console.log("%c========================================", "color: #888; font-weight: bold;");
                        console.log(`%c üéµ NEW TRACK: ${track.artist['#text']} - ${track.name}`, "background: #f0f0f0; color: #000; padding: 5px; font-weight: bold; border: 1px solid #ccc;");
                        
                        setStatus(`Playing: ${track.name}`);
                        stopSlideshow();

                        processTrack(track, currentExecutionID);
                    }
                } else {
                    if (!isIdle && !idleTimer) {
                        setStatus("Silence... Timer started");
                        idleTimer = setTimeout(() => {
                            isIdle = true;
                            stopSlideshow();
                            currentExecutionID++; 
                            fadeOverlay.classList.add('black'); 
                            setStatus("System Idle");
                        }, 60000); 
                    }
                }
            } catch (e) { /* Stil falen */ }
        }

        async function processTrack(track, myExecutionID) {
            const artist = track.artist['#text'];
            const album = track.album['#text'];
            const title = track.name;
            
            let theme = null;
            let highestScore = 0;
            const lowerTitle = title.toLowerCase();
            const lowerArtist = artist.toLowerCase();
            const lowerAlbum = (album || "").toLowerCase();

            // --- DEBUG LOGGING FLAT ---
            console.log(`%c üîç MATCHING...`, "color: #0088ff; font-weight: bold;");
            console.log(`   Artist: "${lowerArtist}"`);
            console.log(`   Album:  "${lowerAlbum}"`);
            console.log(`   Title:  "${lowerTitle}"`);

            if (typeof THEMES !== 'undefined') {
                for (const t of THEMES) {
                    let m = 0;
                    let reasons = [];

                    if (t.match.artist?.some(a => lowerArtist.includes(a.toLowerCase()))) {
                        m++;
                        reasons.push("Artist");
                    }
                    if (t.match.album?.some(al => lowerAlbum.includes(al.toLowerCase()))) { 
                        let points = (lowerAlbum.includes("f1") || lowerAlbum.includes("formula 1")) ? 2 : 1;
                        m += points; 
                        reasons.push(points === 2 ? "Album (F1 Bonus)" : "Album");
                    }
                    if (t.match.track) {
                        if (t.match.track.some(tr => lowerTitle === tr.toLowerCase())) {
                            m += 3; 
                            reasons.push("Track (Exact)");
                        }
                        else if (t.match.track.some(tr => lowerTitle.includes(tr.toLowerCase()))) {
                            m++; 
                            reasons.push("Track (Partial)");
                        }
                    }

                    if (m > 0) {
                        console.log(`   üëâ [${t.folder.padEnd(10)}] Score: ${m} (${reasons.join(", ")})`);
                    }

                    if (m > highestScore) { highestScore = m; theme = t; }
                }
            } else {
                console.warn("‚ö†Ô∏è THEMES array missing!");
            }

            if (theme) {
                console.log(`%c ‚úÖ WINNER: ${theme.folder} (Score: ${highestScore})`, "color: green; font-weight: bold;");
            } else {
                console.log(`%c ‚ùå NO MATCH FOUND - Using Cover`, "color: #b30000; font-weight: bold;");
            }
            // --------------------------

            if (myExecutionID !== currentExecutionID) {
                console.log("üõë STOP: Track changed during matching.");
                return;
            }

            if (theme) {
                setStatus(`Theme: ${theme.folder.toUpperCase()}`);
                startSlideshow(theme);
            } else {
                setStatus("Fetching Online Cover...");
                
                const coverUrl = await findHighResCover(artist, title, track.image[3]['#text']);
                
                if (myExecutionID !== currentExecutionID) return;

                preloadAndDecode(coverUrl).then(() => {
                    if (myExecutionID !== currentExecutionID) return;

                    performTransition(coverUrl, true);
                    
                    console.log(`%c üñºÔ∏è COVER ART: ${coverUrl.includes('deezer') ? 'Deezer XL' : (coverUrl.includes('apple') ? 'iTunes' : 'Last.FM')}`, "color: #800080; font-weight: bold;");
                    console.log(`%c URL: ${coverUrl}`, "color: #666; font-size: 10px;");
                });
            }
        }

        async function findHighResCover(a, t, fallback) {
            const query = encodeURIComponent(`${t} ${a}`);
            try {
                const r = await fetch(`https://corsproxy.io/?https://api.deezer.com/search/track?q=${query}`);
                const d = await r.json();
                if (d.data?.[0]?.album?.cover_xl) return d.data[0].album.cover_xl;
            } catch (e) {}
            try {
                const r = await fetch(`https://itunes.apple.com/search?term=${query}&media=music&limit=1`);
                const d = await r.json();
                if (d.results?.[0]) return d.results[0].artworkUrl100.replace('100x100bb', '1200x1200bb');
            } catch (e) {}
            return fallback;
        }

        console.log("%c üöÄ ENGINE READY (v2.2 Flat Log)", "background: #006400; color: white; padding: 5px;");
        fetchLastFm();
        setInterval(fetchLastFm, 5000);

    </script>
</body>
</html>
